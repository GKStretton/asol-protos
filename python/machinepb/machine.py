# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: machine.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List

import betterproto


class SolenoidValve(betterproto.Enum):
    """used in requests"""

    VALVE_UNDEFINED = 0
    VALVE_DRAIN = 1
    VALVE_WATER = 2
    VALVE_MILK = 3
    VALVE_AIR = 4


class Mode(betterproto.Enum):
    UNDEFINED_MODE = 0
    MANUAL = 1
    AUTONOMOUS = 2


class Status(betterproto.Enum):
    UNDEFINED_STATUS = 0
    ERROR = 1
    E_STOP_ACTIVE = 5
    SLEEPING = 6
    SHUTTING_DOWN = 9
    WAKING_UP = 10
    CALIBRATING = 20
    IDLE_STATIONARY = 30
    IDLE_MOVING = 31
    RINSING_PIPETTE = 40
    DISPENSING = 50
    WAITING_FOR_DISPENSE = 55
    COLLECTING = 60
    NAVIGATING_IK = 70
    NAVIGATING_OUTER = 75


class FluidType(betterproto.Enum):
    FLUID_UNDEFINED = 0
    FLUID_DRAIN = 1
    FLUID_WATER = 2
    FLUID_MILK = 3


@dataclass
class PipetteState(betterproto.Message):
    spent: bool = betterproto.bool_field(1)
    vial_held: int = betterproto.uint32_field(2)
    volume_target_ul: float = betterproto.float_field(3)
    # incremented every time a dispense is requested
    dispense_request_number: int = betterproto.uint32_field(4)


@dataclass
class CollectionRequest(betterproto.Message):
    completed: bool = betterproto.bool_field(1)
    request_number: int = betterproto.uint64_field(2)
    vial_number: int = betterproto.uint64_field(3)
    volume_ul: float = betterproto.float_field(4)


@dataclass
class MovementDetails(betterproto.Message):
    # ik target from -1 to 1
    target_x_unit: float = betterproto.float_field(1)
    # ik target from -1 to 1
    target_y_unit: float = betterproto.float_field(2)
    # ik z target in mm
    target_z_ik: float = betterproto.float_field(5)
    # fk target in degrees
    target_ring_deg: float = betterproto.float_field(10)
    # fk target in degrees
    target_yaw_deg: float = betterproto.float_field(11)


@dataclass
class FluidRequest(betterproto.Message):
    fluid_type: "FluidType" = betterproto.enum_field(1)
    volume_ml: float = betterproto.float_field(2)
    complete: bool = betterproto.bool_field(3)
    # if true, open drain while request is taking place (e.g. for rinsing with
    # water)
    open_drain: bool = betterproto.bool_field(4)


@dataclass
class FluidDetails(betterproto.Message):
    bowl_fluid_level_ml: float = betterproto.float_field(1)


@dataclass
class StateReport(betterproto.Message):
    # timestamp in microseconds since unix epoch, UTC. Added by gateway since
    # firmware doesn't know real time.
    timestamp_unix_micros: int = betterproto.uint64_field(2)
    # incremented on startup, currently 1 byte
    startup_counter: int = betterproto.uint64_field(3)
    mode: "Mode" = betterproto.enum_field(4)
    status: "Status" = betterproto.enum_field(5)
    # Useful for synchronisation with footage
    lights_on: bool = betterproto.bool_field(6)
    pipette_state: "PipetteState" = betterproto.message_field(10)
    collection_request: "CollectionRequest" = betterproto.message_field(11)
    movement_details: "MovementDetails" = betterproto.message_field(12)
    fluid_request: "FluidRequest" = betterproto.message_field(13)
    fluid_details: "FluidDetails" = betterproto.message_field(14)
    # the following are populated by the backend, useful in post-processing
    paused: bool = betterproto.bool_field(50)
    timestamp_readable: str = betterproto.string_field(51)
    # e.g. 1 for 0001.jpg
    latest_dslr_file_number: int = betterproto.uint64_field(52)


@dataclass
class StateReportList(betterproto.Message):
    state_reports: List["StateReport"] = betterproto.message_field(1)


@dataclass
class SessionStatus(betterproto.Message):
    id: int = betterproto.uint64_field(1)
    paused: bool = betterproto.bool_field(2)
    complete: bool = betterproto.bool_field(3)
    production: bool = betterproto.bool_field(4)
    production_id: int = betterproto.uint64_field(5)


@dataclass
class StreamStatus(betterproto.Message):
    live: bool = betterproto.bool_field(1)


@dataclass
class DispenseMetadataMap(betterproto.Message):
    # [startupCounter]_[dispenseRequestNumber]
    dispense_metadata: Dict[str, "DispenseMetadata"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class DispenseMetadata(betterproto.Message):
    failed_dispense: bool = betterproto.bool_field(1)
    # how many ms later than expected the dispense happened
    dispense_delay_ms: int = betterproto.uint64_field(2)
